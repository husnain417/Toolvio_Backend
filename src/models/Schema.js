const mongoose = require('mongoose');

const SchemaDefinitionSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
    match: [/^[a-z][a-z0-9_]*$/, 'Schema name must start with letter and contain only lowercase letters, numbers, and underscores']
  },
  displayName: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  jsonSchema: {
    type: Object,
    required: true,
    validate: {
      validator: function(v) {
        // Must be an object
        if (!v || typeof v !== 'object') return false;
        
        // Must have type: "object"
        if (v.type !== 'object') return false;
        
        // Must have properties
        if (!v.properties || typeof v.properties !== 'object') return false;
        
        // At least one property must exist
        if (Object.keys(v.properties).length === 0) return false;
        
        // Validate each property has a valid type or $ref
        for (const [propName, propDef] of Object.entries(v.properties)) {
          if (propDef.$ref) {
            // $ref properties are valid
            continue;
          }
          if (!propDef.type || !['string', 'number', 'integer', 'boolean', 'array', 'object'].includes(propDef.type)) {
            return false;
          }
        }
        
        return true;
      },
      message: 'jsonSchema must be a valid JSON Schema with type "object", properties, and valid field types or $ref'
    }
  },
  // Track relationships between schemas for change propagation
  relationships: [{
    field: {
      type: String,
      required: true
    },
    referencedSchema: {
      type: String,
      required: true
    },
    referenceType: {
      type: String,
      enum: ['reference', 'array_reference'],
      default: 'reference'
    },
    isRequired: {
      type: Boolean,
      default: false
    }
  }],
  version: {
    type: String,
    default: '1.0.0'
  },
  isActive: {
    type: Boolean,
    default: true
  },
  collectionName: {
    type: String,
    required: false // Auto-generated by pre-save middleware
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Update the updatedAt field before saving
SchemaDefinitionSchema.pre('save', function(next) {
  if (this.isModified()) {
    this.updatedAt = new Date();
  }
  next();
});

// Generate collection name from schema name
SchemaDefinitionSchema.pre('save', function(next) {
  // Always ensure collectionName is set
  if (!this.collectionName || this.isNew || this.isModified('name')) {
    this.collectionName = `dynamic_${this.name}`;
  }
  next();
});

// Extract relationships from JSON Schema
SchemaDefinitionSchema.pre('save', function(next) {
  if (this.jsonSchema && this.jsonSchema.properties) {
    const relationships = [];
    
    for (const [fieldName, fieldDef] of Object.entries(this.jsonSchema.properties)) {
      // Check for x-ref property (new approach)
      if (fieldDef['x-ref']) {
        relationships.push({
          field: fieldName,
          referencedSchema: fieldDef['x-ref'],
          referenceType: fieldDef['x-ref-type'] === 'array' || fieldDef.type === 'array' ? 'array_reference' : 'reference',
          isRequired: this.jsonSchema.required && this.jsonSchema.required.includes(fieldName)
        });
      }
      
      // Check array items for x-ref
      if (fieldDef.type === 'array' && fieldDef.items && fieldDef.items['x-ref']) {
        relationships.push({
          field: fieldName,
          referencedSchema: fieldDef.items['x-ref'],
          referenceType: 'array_reference',
          isRequired: this.jsonSchema.required && this.jsonSchema.required.includes(fieldName)
        });
      }
      
      // Keep backward compatibility with $ref
      if (fieldDef.$ref) {
        const refPath = fieldDef.$ref;
        let referencedSchema = '';
        
        if (refPath.startsWith('#/definitions/')) {
          referencedSchema = refPath.replace('#/definitions/', '');
        } else if (refPath.startsWith('#/')) {
          referencedSchema = refPath.replace('#/', '');
        } else {
          referencedSchema = refPath;
        }
        
        if (referencedSchema) {
          relationships.push({
            field: fieldName,
            referencedSchema: referencedSchema,
            referenceType: fieldDef.items ? 'array_reference' : 'reference',
            isRequired: this.jsonSchema.required && this.jsonSchema.required.includes(fieldName)
          });
        }
      }
    }
    
    this.relationships = relationships;
  }
  next();
});

// Virtual for collection name (read-only)
SchemaDefinitionSchema.virtual('collectionNameVirtual').get(function() {
  return this.collectionName || `dynamic_${this.name}`;
});

// Ensure virtual fields are serialized
SchemaDefinitionSchema.set('toJSON', { virtuals: true });
SchemaDefinitionSchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('SchemaDefinition', SchemaDefinitionSchema);